use crate::BomData;
use chrono::{DateTime, Local};
use std::fs;
use std::io::Write;
use std::path::Path;

/// 登録名リストをJSON形式で保存
pub async fn save_dictionary(
    bom_data: &BomData,
    file_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut dictionary = std::collections::HashMap::new();

    for row in &bom_data.rows {
        dictionary.insert(row.part_number.clone(), row.model_number.clone());
    }

    let json_content = serde_json::to_string_pretty(&dictionary)?;
    fs::write(file_path, json_content)?;

    Ok(())
}

/// 登録名リストをJSON形式で読み込み
pub async fn load_dictionary(
    file_path: &str,
) -> Result<std::collections::HashMap<String, String>, Box<dyn std::error::Error>> {
    if !Path::new(file_path).exists() {
        return Ok(std::collections::HashMap::new());
    }

    let content = fs::read_to_string(file_path)?;
    let dictionary: std::collections::HashMap<String, String> = serde_json::from_str(&content)?;

    Ok(dictionary)
}

/// 現在の日時をYYYYMMDD形式で取得
pub fn get_current_date_string() -> String {
    let now: DateTime<Local> = Local::now();
    now.format("%Y%m%d").to_string()
}

/// ファイル名に日時を追加
pub fn add_timestamp_to_filename(file_path: &str, prefix: &str) -> String {
    let path = Path::new(file_path);
    let parent = path.parent().unwrap_or(Path::new("."));
    let stem = path.file_stem().unwrap_or(std::ffi::OsStr::new("file"));
    let extension = path.extension().unwrap_or(std::ffi::OsStr::new(""));

    let timestamp = get_current_date_string();
    let filename = format!("{}_{}_{}", prefix, timestamp, stem.to_string_lossy());

    parent
        .join(format!("{}.{}", filename, extension.to_string_lossy()))
        .to_string_lossy()
        .to_string()
}

/// CSV形式でファイルを保存
pub async fn save_csv_file(
    data: &[Vec<String>],
    file_path: &str,
    encoding: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut file = fs::File::create(file_path)?;

    // BOMを追加（UTF-8の場合）
    let encoding_lower = encoding.to_ascii_lowercase();

    if encoding_lower == "utf-8" {
        file.write_all(&[0xEF, 0xBB, 0xBF])?;
    }

    for row in data {
        let csv_line = row.join(",") + "\n";
        let bytes = match encoding_lower.as_str() {
            "utf-8" => csv_line.as_bytes().to_vec(),
            "shift-jis" => {
                let (encoded, _, _) = encoding_rs::SHIFT_JIS.encode(&csv_line);
                encoded.to_vec()
            }
            _ => csv_line.as_bytes().to_vec(),
        };
        file.write_all(&bytes)?;
    }

    Ok(())
}

/// TXT形式でファイルを保存
pub async fn save_txt_file(
    content: &str,
    file_path: &str,
    encoding: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let encoding_lower = encoding.to_ascii_lowercase();

    let bytes = match encoding_lower.as_str() {
        "utf-8" => content.as_bytes().to_vec(),
        "shift-jis" => {
            let (encoded, _, _) = encoding_rs::SHIFT_JIS.encode(content);
            encoded.to_vec()
        }
        _ => content.as_bytes().to_vec(),
    };

    fs::write(file_path, bytes)?;
    Ok(())
}

/// PartsSaver用のALL.csv形式で保存
pub async fn save_parts_saver_format(
    bom_data: &BomData,
    file_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut csv_data = Vec::new();

    // ヘッダー行
    csv_data.push(bom_data.headers.clone());

    // データ行（空白行を含む）
    for row in &bom_data.rows {
        let mut csv_row = Vec::new();
        for header in &bom_data.headers {
            let value = row.attributes.get(header).unwrap_or(&String::new()).clone();
            csv_row.push(value);
        }
        csv_data.push(csv_row);

        // 空白行を追加
        csv_data.push(vec![String::new(); bom_data.headers.len()]);
    }

    save_csv_file(&csv_data, file_path, "utf-8").await?;
    Ok(())
}

/// partECO形式で保存
pub async fn save_part_eco_format(
    bom_data: &BomData,
    file_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut content = String::new();

    content.push_str("# partECO format\n");
    content.push_str("# Generated by Kyoden BOM Tool\n");
    content.push_str(&format!("# Date: {}\n", get_current_date_string()));
    content.push_str("\n");

    for row in &bom_data.rows {
        content.push_str(&format!("{};{}\n", row.part_number, row.model_number));
    }

    save_txt_file(&content, file_path, "utf-8").await?;
    Ok(())
}

/// partCCF形式で保存
pub async fn save_part_ccf_format(
    bom_data: &BomData,
    file_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut content = String::new();

    content.push_str("# partCCF format\n");
    content.push_str("# Generated by Kyoden BOM Tool\n");
    content.push_str(&format!("# Date: {}\n", get_current_date_string()));
    content.push_str("\n");

    for row in &bom_data.rows {
        content.push_str(&format!("CCF:{}:{}\n", row.part_number, row.model_number));
    }

    save_txt_file(&content, file_path, "utf-8").await?;
    Ok(())
}

/// partMSF形式で保存
pub async fn save_part_msf_format(
    bom_data: &BomData,
    file_path: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut content = String::new();

    content.push_str("# partMSF format\n");
    content.push_str("# Generated by Kyoden BOM Tool\n");
    content.push_str(&format!("# Date: {}\n", get_current_date_string()));
    content.push_str("\n");

    for row in &bom_data.rows {
        content.push_str(&format!("MSF:{}:{}\n", row.part_number, row.model_number));
    }

    save_txt_file(&content, file_path, "utf-8").await?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_current_date_string() {
        let date_str = get_current_date_string();
        assert_eq!(date_str.len(), 8);
        assert!(date_str.chars().all(|c| c.is_ascii_digit()));
    }

    #[test]
    fn test_add_timestamp_to_filename() {
        let result = add_timestamp_to_filename("/path/to/file.csv", "comparison");
        assert!(result.contains("comparison_"));
        assert!(result.contains("file.csv"));
    }
}
